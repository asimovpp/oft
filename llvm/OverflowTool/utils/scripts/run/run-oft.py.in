#!/usr/bin/env python3

# TODO
# option for file suffix and output
# pass through commands to opt
# discover llvm assertion mode

from typing import List, Optional
from itertools import chain

import os
import sys
import subprocess
import click

LIB_DIR = os.getcwd() + '/lib64'
LIBPASS = 'libLLVMOverflowToolPass.so'


class DefaultOptOptions(dict):
    def __init__(self, **kwargs):
        defaults = {
            'executable': 'opt',
            'pass_name': 'missing-pass-name',
            'analysis': True,
            'printing': False,
            'debug_only_filters': []
        }
        super().__init__(defaults)
        super().update(**kwargs)


class OptRunnerMixin:
    def _construct(self, dict_instance):
        cmdline = []
        cmdline.append(dict_instance.get('executable'))
        # TODO fix access to global
        cmdline.append(f'-load {LIB_DIR}/{LIBPASS}')  # hack for cmdline options
        cmdline.append(f'-load-pass-plugin={LIB_DIR}/{LIBPASS}')

        invocation = 'require' if dict_instance.get('analysis') else 'pass'
        if dict_instance.get('printing'):
            invocation = 'print'
        invocation += '<' + dict_instance.get('pass_name') + '>'

        pipeline = f'-passes="{invocation}"'

        cmdline.append(pipeline)

        cmdline.extend(dict_instance.get('rest').split())

        return cmdline

    def run(self):
        print(self._construct(self.__dict__))
        return subprocess.Popen(self._construct(self.__dict__),
                                stdout=sys.stdout)


class OptRunner(OptRunnerMixin):
    def __init__(self, opts=DefaultOptOptions(), **kwargs):
        self.__dict__.update(**opts)
        self.__dict__.update(**kwargs)


@click.command(context_settings=dict(
    ignore_unknown_options=True,
))
@click.option('--config-file', '-f', 'config_files', multiple=True,
              type=click.Path(exists=True, dir_okay=False, resolve_path=True))
@click.option('--config-dir', '-d', 'config_dirs', multiple=True,
              type=click.Path(exists=True, file_okay=False, resolve_path=True))
@click.argument('llvmopt_args', nargs=-1, type=click.UNPROCESSED)
@click.pass_context
def annotate(ctx, config_files, config_dirs: Optional[List[str]], llvmopt_args):
    """Run annotate passes"""
    print(llvmopt_args)

    annotate_options = {
        'pass_name': 'oft-manual-annotation-seletion',
        'printing': ctx.obj['printing']
    }

    annotate_options.update(
        {'debug_only_filters': ['oft-manual-annotation-selection',
                                'oft-manual-annotation-selection-analysis'] if ctx.obj['debug'] else []})

    rest_options = ''
    files = (os.path.abspath(f) for d in config_dirs for f in os.listdir(d))
    for f in chain(files, config_files):
        rest_options += f'-oft-annotation-file {f} '

    f = ctx.obj['output']
    if f:
        rest_options += f'-o {f}'

    annotate_options.update(
        {'rest':  rest_options})

    opt = OptRunner(**annotate_options)
    opt.run()


@click.command(context_settings=dict(
    ignore_unknown_options=True,
))
@click.argument('llvmopt_args', nargs=-1, type=click.UNPROCESSED)
@click.pass_context
def trace(ctx, llvmopt_args):
    """Run trace passes"""
    pass


@click.group()
@click.option('--debug/--no-debug', '-d', default=False)
@click.option('--print/--no-print', '-p', 'printing', default=False)
@click.option('--output', '-o', type=click.STRING)
@click.pass_context
def cli(ctx, debug: bool, printing: bool, output: Optional[str]):
    # ensure that ctx.obj exists and is a dict (in case `cli()` is called
    # by means other than the `if` block below)
    ctx.ensure_object(dict)

    ctx.obj['debug'] = debug
    ctx.obj['printing'] = printing
    ctx.obj['output'] = output


if __name__ == '__main__':
    context_settings = dict(help_option_names=['-h', '--help'])
    cli.add_command(annotate)
    cli.add_command(trace)
    cli.context_settings.update(context_settings)
    cli()
